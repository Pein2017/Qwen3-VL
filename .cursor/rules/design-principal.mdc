---
alwaysApply: true
---
### **Configuration**

* No silent defaults for core params; all explicit via YAML/CLI/constructor.
* Single frozen schema (`@dataclass(frozen=True)`) with required → optional order.
* Derived paths only for non-core fields (log derivation).
* Dedicated validation function; raise immediately on invalid values.
* No CLI/env access inside library code — only in `config/`.

---

### **Interfaces & APIs**

* Small, consistent public surface.
* Group params into typed config objects (no `**kwargs`).
* Predictable returns (`dataclass`, `TypedDict`, or defined dicts).
* Lightweight constructors; heavy logic in explicit methods.
* Inject dependencies (`rng`, config, processors); no globals.
* Stable naming across modules (`build`, `encode`, `preprocess`).

---

### **Abstraction & Dependencies**

* Depend on ABCs/Protocols; compose instead of inherit.
* Clean import graph:
  `config → runner → {datasets, builders, preprocessors} → utils`
  (never import upward).
* Extend via new `Builder` / `Preprocessor` / `Template`, not by editing core logic.

---

### **Module Contracts**

**Training / Models / Processing**

* Validate shapes, counts, spans, and offsets — fail on mismatch.
* Separate model vs training config; no proxy confusion.
* Fail on non-finite loss or invalid gradients.
* Checkpoints must store full metadata; reproducibility best-effort with seeds.

**Data Conversion**

* Enforce object types & geometry constraints; never auto-correct.
* Frozen config with required dirs & object types.
* CLI exits non-zero on invalid input.

---

### **Error Handling**

* No broad `try/except` or silent `pass`.
* `assert` only for invariants (not user input).
* Errors include *expected vs actual* + remediation hint.
* `try/finally` for cleanup only, must re-raise.

---

### **Typing & Standards**

* Strong typing; no `Any`.
* Centralize domain types.
* Use `@dataclass(frozen=True)` for value objects.
* For tensors: enforce typed boundaries (`jaxtyping`, `beartype`).
* No wildcard imports, mutable globals, or monkey-patching.

---

### **CI & Quality**

* Pre-commit: format, lint, type-check.
* Warnings = errors in tests.
* Tests cover interfaces; integration at runner layer.
* Commits describe intent and visible effect.

---

### **Merge Checklist**

✅ Explicit config, typed API
✅ Early validation, no hidden state
✅ Clean imports, no broad `try/except`
✅ Uses or implements an interface
✅ Deterministic behavior where possible

---

### **When Unsure**

* Pause and clarify intent before coding.
* If requirements, data flow, or contracts are ambiguous, engage in a short discussion to define them precisely.
* Ask targeted questions to confirm expectations, then propose the simplest explicit design that fails fast and keeps interfaces small.
